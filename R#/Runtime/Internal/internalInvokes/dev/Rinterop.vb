#Region "Microsoft.VisualBasic::75b54ca873b7904e85e514a890f20aad, D:/GCModeller/src/R-sharp/R#//Runtime/Internal/internalInvokes/Rinterop.vb"

' Author:
' 
'       asuka (amethyst.asuka@gcmodeller.org)
'       xie (genetics@smrucc.org)
'       xieguigang (xie.guigang@live.com)
' 
' Copyright (c) 2018 GPL3 Licensed
' 
' 
' GNU GENERAL PUBLIC LICENSE (GPL3)
' 
' 
' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.
' 
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
' 
' You should have received a copy of the GNU General Public License
' along with this program. If not, see <http://www.gnu.org/licenses/>.



' /********************************************************************************/

' Summaries:


' Code Statistics:

'   Total Lines: 62
'    Code Lines: 18
' Comment Lines: 39
'   Blank Lines: 5
'     File Size: 2.74 KB


'     Module Rinterop
' 
'         Function: Rcall, Rload
' 
' 
' /********************************************************************************/

#End Region

Imports System.Reflection
Imports System.Reflection.Emit
Imports Microsoft.VisualBasic.ApplicationServices.DynamicInterop
Imports Microsoft.VisualBasic.CommandLine.Reflection
Imports Microsoft.VisualBasic.Linq
Imports SMRUCC.Rsharp.Runtime.Internal.Object
Imports SMRUCC.Rsharp.Runtime.Interop

Namespace Runtime.Internal.Invokes

    Module Rinterop

        Const external_native_call_name As String = "Invoke"

        ''' <summary>
        ''' Modern Interfaces to VisualBasic.NET code
        ''' 
        ''' Functions to pass R# objects to compiled VisualBasic.NET code that has been loaded into R#.
        ''' </summary>
        ''' <param name="NAME">
        ''' a character string giving the name of a C function, or an object 
        ''' of class "NativeSymbolInfo", "RegisteredNativeSymbol" or 
        ''' "NativeSymbol" referring to such a name.</param>
        ''' <param name="PACKAGE">
        ''' If supplied, confine the search For a character String .NAME To 
        ''' the DLL given by this argument (plus the conventional extension, 
        ''' '.so’, ‘.dll’, ...).
        ''' This argument follows ... And so its name cannot be abbreviated.
        ''' This Is intended to add safety for packages, which can ensure by 
        ''' using this argument that no other package can override their 
        ''' external symbols, And also speeds up the search (see 'Note’).
        ''' </param>
        ''' <param name="args">
        ''' arguments to be passed to the compiled code. Up to 65 for .Call.
        ''' </param>
        ''' <param name="env"></param>
        ''' <returns>An R object constructed in the compiled code.</returns>
        <ExportAPI(".Call")>
        Public Function Rcall(NAME As String, PACKAGE As String,
                              <RListObjectArgument>
                              Optional args As list = Nothing,
                              Optional env As Environment = Nothing) As Object

            ' # This file was generated by Rcpp::compileAttributes
            ' # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
            '
            ' jaccard_coeff <- function(idx) {
            '    .Call('Rphenograph_jaccard_coeff', PACKAGE = 'Rphenograph', idx)
            ' }
            Dim dll As UnmanagedDll = env.globalEnvironment.nativeLibraries.TryGetValue(PACKAGE)

            If dll Is Nothing Then
                Return Internal.debug.stop({
                    $"Error in .Call(""{NAME}"", PACKAGE = ""{PACKAGE}""): ""{NAME}"" not available for .Call() from native library ""{PACKAGE}""",
                    $"symbol_name: {NAME}",
                    $"native_library: {PACKAGE}"
                }, env)
            End If

            Static get_native_function As MethodInfo = GetType(UnmanagedDll) _
                .GetMethods _
                .Where(Function(m)
                           Return m.Name = NameOf(UnmanagedDll.GetFunction) AndAlso
                                  m.GetParameters.Length = 2
                       End Function) _
                .First

            ' C native library
            ' MY_C_API_MARKER void Play(void* simulation, const char* variableIdentifier, double* values, TimeSeriesGeometry* geom);
            '
            ' .net clr
            ' private delegate void Play_csdelegate(IntPtr simulation, string variableIdentifier, IntPtr values, IntPtr geom);
            ' // and somewhere in a class a field is set:
            ' NativeLib = new UnmanagedDll(someNativeLibFilename);

            ' void Play_cs(IModelSimulation simulation, string variableIdentifier, double[] values, ref MarshaledTimeSeriesGeometry geom)
            ' {
            '    IntPtr values_doublep, geom_struct;
            '    // here glue code here to create native arrays/structs
            '    NativeLib.GetFunction<Play_csdelegate>("Play")(CheckedDangerousGetHandle(simulation, "simulation"), variableIdentifier, values_doublep, geom_struct);
            '    // here copy args back to managed; clean up transient native resources.
            ' }
            Dim [return] As String = args.GetString("return")
            ' make a delegate type at here
            ' the parameter type is generated from the arguments
            ' and also then parameter order is generated from the argument order in the list
            Dim keys As String() = args.getNames _
                .Where(Function(si) si <> NameOf([return])) _
                .ToArray
            Dim argv As Object() = New Object(keys.Length - 1) {}
            Dim params As Type() = New Type(keys.Length - 1) {}
            Dim returnType As Type = Nothing

            If [return].StringEmpty Then
                returnType = Nothing
            Else
                Select Case [return]
                    Case "i32" : returnType = GetType(Integer)
                End Select
            End If

            For i As Integer = 0 To keys.Length - 1
                argv(i) = args.getByName(keys(i))
                params(i) = argv(i).GetType

                If params(i) Is GetType(String) Then
                    argv(i) = CStr(argv(i)).ToArray
                    params(i) = GetType(Char())
                End If
            Next
            Dim del As Type = getDelegate(params, returnVal:=returnType)
            ' run function with reflection
            Dim native_func As [Delegate] = get_native_function.Invoke(dll, parameters:=New Object() {NAME, del})
            Dim result = native_func.DynamicInvoke(argv)

            Return result
        End Function

        Private Function getDelegate(params As Type(), returnVal As Type) As Type
            Dim tdelegate As TypeBuilder = DynamicType.GetTypeBuilder("native_delegate_func", GetType(MulticastDelegate), isAbstract:=True, sealed:=True)
            Dim new_fp = tdelegate.DefineConstructor(MethodAttributes.RTSpecialName Or
                                                     MethodAttributes.HideBySig Or
                                                     MethodAttributes.Public,
                                                     CallingConventions.Standard, {GetType(Object), GetType(IntPtr)})
            Dim native_calls = tdelegate.DefineMethod(external_native_call_name,
                                                      MethodAttributes.RTSpecialName Or
                                                      MethodAttributes.Public Or
                                                      MethodAttributes.HideBySig Or
                                                      MethodAttributes.NewSlot Or
                                                      MethodAttributes.Virtual, CallingConventions.Standard, returnVal, params)

            new_fp.SetImplementationFlags(MethodImplAttributes.CodeTypeMask)
            native_calls.SetImplementationFlags(MethodImplAttributes.CodeTypeMask)

            Return tdelegate.CreateType
        End Function


        ''' <summary>
        ''' imports VB.NET namespace
        ''' </summary>
        ''' <param name="[namespace]">
        ''' only import of the instance method from 
        ''' the given types in the target namespace 
        ''' value.
        ''' </param>
        ''' <param name="env"></param>
        ''' <returns></returns>
        <ExportAPI(".Load")>
        Public Function Rload([namespace] As String, Optional env As Environment = Nothing) As Object
            Throw New NotImplementedException
        End Function
    End Module
End Namespace
