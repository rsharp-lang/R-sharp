Imports System.Reflection
Imports System.Reflection.Emit
Imports Microsoft.VisualBasic.ApplicationServices.DynamicInterop
Imports Microsoft.VisualBasic.CommandLine.Reflection
Imports SMRUCC.Rsharp.Runtime.Internal.Object
Imports SMRUCC.Rsharp.Runtime.Interop
Imports SMRUCC.Rsharp.Runtime.Vectorization

Namespace Runtime.Internal.Invokes

    ''' <summary>
    ''' the rust language helper
    ''' </summary>
    Public Module rust

        Private Function SolveCLibrary(x As String, env As Environment) As String
            If x.FileExists Then
                Return x
            ElseIf TypeOf env Is PackageEnvironment Then
                Dim pkg As PackageEnvironment = env
                Dim dir As String = $"{pkg.libpath}/lib_c/"
                Dim fileName As String = $"{dir}/{x}"

                If fileName.FileExists Then
                    Return fileName
                Else
                    GoTo FIND_RENV
                End If
            Else
FIND_RENV:
                For Each dir As String In New String() {
                    App.HOME,
                    $"{App.HOME}/lib/",
                    $"{App.HOME}/lib_c/",
                    $"{App.HOME}/../lib/",
                    $"{App.HOME}/../lib_c/"
                }
                    If $"{dir}/{x}".FileExists Then
                        Return $"{dir}/{x}"
                    End If
                Next

                Return x
            End If
        End Function

        ''' <summary>
        ''' ### Foreign Function Interface
        ''' 
        ''' Load or unload DLLs (also known as shared objects), and test whether a 
        ''' C function or Fortran subroutine is available.
        ''' </summary>
        ''' <returns></returns>
        ''' <param name="x">
        ''' a character string giving the pathname to a DLL, also known as a dynamic 
        ''' shared object. (See ‘Details’ for what these terms mean.)
        ''' </param>
        <ExportAPI("dyn.load")>
        Public Function dynLoad(x As String, Optional env As Environment = Nothing) As Object
            Dim dll As New UnmanagedDll(dllName:=SolveCLibrary(x, env))
            Dim globalEnv = env.globalEnvironment
            Dim libc_key As String = x.BaseName

            ' hook current library to runtime environment
            globalEnv.nativeLibraries(libc_key) = dll

            Return dll
        End Function

        Const external_native_call_name As String = "Invoke"

        ''' <summary>
        ''' Modern Interfaces to VisualBasic.NET code
        ''' 
        ''' Functions to pass R# objects to compiled VisualBasic.NET code that has been loaded into R#.
        ''' </summary>
        ''' <param name="NAME">
        ''' a character string giving the name of a C function, or an object 
        ''' of class "NativeSymbolInfo", "RegisteredNativeSymbol" or 
        ''' "NativeSymbol" referring to such a name.</param>
        ''' <param name="PACKAGE">
        ''' If supplied, confine the search For a character String .NAME To 
        ''' the DLL given by this argument (plus the conventional extension, 
        ''' '.so’, ‘.dll’, ...).
        ''' This argument follows ... And so its name cannot be abbreviated.
        ''' This Is intended to add safety for packages, which can ensure by 
        ''' using this argument that no other package can override their 
        ''' external symbols, And also speeds up the search (see 'Note’).
        ''' </param>
        ''' <param name="args">
        ''' arguments to be passed to the compiled code. Up to 65 for .Call.
        ''' </param>
        ''' <param name="env"></param>
        ''' <returns>An R object constructed in the compiled code.</returns>
        <ExportAPI(".Call")>
        Public Function Rcall(NAME As String, PACKAGE As String,
                              <RListObjectArgument>
                              Optional args As List = Nothing,
                              Optional env As Environment = Nothing) As Object

            ' # This file was generated by Rcpp::compileAttributes
            ' # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
            '
            ' jaccard_coeff <- function(idx) {
            '    .Call('Rphenograph_jaccard_coeff', PACKAGE = 'Rphenograph', idx)
            ' }
            Dim dll As UnmanagedDll = env.globalEnvironment.nativeLibraries.TryGetValue(PACKAGE)

            If dll Is Nothing Then
                Return Internal.debug.stop({
                    $"Error in .Call(""{NAME}"", PACKAGE = ""{PACKAGE}""): ""{NAME}"" not available for .Call() from native library ""{PACKAGE}""",
                    $"symbol_name: {NAME}",
                    $"native_library: {PACKAGE}"
                }, env)
            End If

            Static get_native_function As MethodInfo = GetType(UnmanagedDll) _
                .GetMethods _
                .Where(Function(m)
                           Return m.Name = NameOf(UnmanagedDll.GetFunction) AndAlso
                                  m.GetParameters.Length = 2
                       End Function) _
                .First

            ' C native library
            ' MY_C_API_MARKER void Play(void* simulation, const char* variableIdentifier, double* values, TimeSeriesGeometry* geom);
            '
            ' .net clr
            ' private delegate void Play_csdelegate(IntPtr simulation, string variableIdentifier, IntPtr values, IntPtr geom);
            ' // and somewhere in a class a field is set:
            ' NativeLib = new UnmanagedDll(someNativeLibFilename);

            ' void Play_cs(IModelSimulation simulation, string variableIdentifier, double[] values, ref MarshaledTimeSeriesGeometry geom)
            ' {
            '    IntPtr values_doublep, geom_struct;
            '    // here glue code here to create native arrays/structs
            '    NativeLib.GetFunction<Play_csdelegate>("Play")(CheckedDangerousGetHandle(simulation, "simulation"), variableIdentifier, values_doublep, geom_struct);
            '    // here copy args back to managed; clean up transient native resources.
            ' }
            Dim [return] As String = args.GetString("return")
            ' make a delegate type at here
            ' the parameter type is generated from the arguments
            ' and also then parameter order is generated from the argument order in the list
            Dim keys As String() = args.getNames _
                .Where(Function(si) si <> NameOf([return])) _
                .ToArray
            Dim argv As Object() = New Object(keys.Length - 1) {}
            Dim params As Type() = New Type(keys.Length - 1) {}
            Dim returnType As Type = Nothing

            If [return].StringEmpty Then
                returnType = Nothing
            Else
                Select Case [return]
                    Case "i32" : returnType = GetType(Integer)
                    Case "string" : returnType = GetType(String)
                End Select
            End If

            For i As Integer = 0 To keys.Length - 1
                argv(i) = args.getByName(keys(i))
                params(i) = argv(i).GetType
            Next
            Dim del As Type = getDelegate(params, returnVal:=returnType)
            ' run function with reflection
            Dim native_func As [Delegate] = get_native_function.Invoke(dll, parameters:=New Object() {NAME, del})
            Dim result = native_func.DynamicInvoke(argv)

            Return result
        End Function

        Private Function getDelegate(params As Type(), returnVal As Type) As Type
            Dim tdelegate As TypeBuilder = DynamicType.GetTypeBuilder("native_delegate_func", GetType(MulticastDelegate), isAbstract:=True, sealed:=True)
            Dim new_fp = tdelegate.DefineConstructor(MethodAttributes.RTSpecialName Or
                                                     MethodAttributes.HideBySig Or
                                                     MethodAttributes.Public,
                                                     CallingConventions.Standard, {GetType(Object), GetType(IntPtr)})
            Dim native_calls = tdelegate.DefineMethod(external_native_call_name,
                                                      MethodAttributes.RTSpecialName Or
                                                      MethodAttributes.Public Or
                                                      MethodAttributes.HideBySig Or
                                                      MethodAttributes.NewSlot Or
                                                      MethodAttributes.Virtual, CallingConventions.Standard, returnVal, params)

            new_fp.SetImplementationFlags(MethodImplAttributes.CodeTypeMask)
            native_calls.SetImplementationFlags(MethodImplAttributes.CodeTypeMask)

            Return tdelegate.CreateType
        End Function

        ''' <summary>
        ''' create an integer scalar value
        ''' </summary>
        ''' <param name="x"></param>
        ''' <returns></returns>
        <ExportAPI("i32")>
        Public Function i32(x As Object) As Integer
            Return CLRVector.asInteger(x).First
        End Function

        <ExportAPI("string")>
        Public Function [string](s As Object) As String
            Return CLRVector.asCharacter(s).First
        End Function
    End Module
End Namespace